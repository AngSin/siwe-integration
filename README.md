# Prerequisites
1. Have node and npm installed
2. Have docker installed and docker daemon running

# Steps to run
1. run: `docker run --name siwe-postgres -e POSTGRES_PASSWORD=securepassword -e POSTGRES_DB=siwe_db -e POSTGRES_USER=admin -p 5432:5432 -d postgres`
2. install & run server: `cd server && npm i && npm run start:dev`
3. install & run client: `cd client && npm i && npm start`
4. go to http://localhost:3000

# Architectural/Design Decisions:
1. **Database:** Chose PostgreSQL as that is part of the Gnosis Pay stack. It also was sufficient for the use case. If no. of users increased, implementing pagination on it would be easy:
   1. I did not add any auto generated key column since users' ethereum addresses would be unique. However, in a full-fledged production app where there would be other login methods and access patterns, an autogenerated UUID column would make sense.
   2. I did not add any indices on the other columns as there were no other access patterns defined in the task description
   3. I did not add a limit on the no. of characters in a user's bio or name as it was not a business requirement. However, in production it would make sense.
2. **Backend Framework:** I chose to use NestJS as a framework for the Node + Typescript server as it as an opinionated framework like Spring and unlike Express, which I personally prefer as it has more structure.
   1. It helped me create the application using an MVC-like design.
   2. Having unit tests seperated by layer was also made easy by using NestJS.
3. **Connecting to a browser wallet & SIWE:** I used the code linked to via the SIWE website. This means that it is not using wagmi or another tool like it (which also uses deeplinks to redirect user from a browser that does not support browser wallets, to Metamask etc). 
4. **Dev environment:** The SIWE library uses cookies for sessions. Sending a Set-Cookie header from a different port that the backend is running on, would require the cookie to be cross-site and cross site cookies can only be set in an HTTPS connection. To by pass this, the frontend (create-react-app) server in this repo, proxies calls to itself to the port that the backend is running on. By proxying these requests we keep the Cookie as same-site, and thus do not need a cross-site cookie and can have sessions even in localhost during development.
5. **Deployment:** The application is deployed on 1 Amazon-Linux EC2 instance that has docker and node installed.
   1. This was done, so all 3 (database engine, backend & frontend) could live on the same machine and thus be easy to manage.
   2. Since the application is not huge, a single EC2 instance with 4 GB RAM was enough.
   3. The postgres docker image is running on it. The frontend application is built once and also served by the backend server.
   4. Since the origin of the backend and frontend is the same, there is no need for a cross site cookie, which would consequently require to be "secure"/HTTPS-only and so I would  have to create an SSL certification.
   5. In a production environment, I would include a AWS-CDK stack so the infrastructure can live as code and be managed and improved on easily. The CDK stack would ideally include a VPC, Route53 Configuration, Cloudfront, S3, ECS and RDS Instance.
6. **Frontend Framework:** Naturally I used React with Typescript, which is the go-to industry choice right now and also part of the Gnosis Pay stack (as mentioned in the job description).